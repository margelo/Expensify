diff --git a/node_modules/react-native-onyx/lib/Onyx.js b/node_modules/react-native-onyx/lib/Onyx.js
index 7b45997..9fd2622 100644
--- a/node_modules/react-native-onyx/lib/Onyx.js
+++ b/node_modules/react-native-onyx/lib/Onyx.js
@@ -73,6 +73,8 @@ const reduceCollectionWithSelector = (collection, selector, withOnyxInstanceStat
     return finalCollection;
 }, {});
 
+
+
 /**
  * Get some data from the store
  *
@@ -104,6 +106,10 @@ function get(key) {
     return cache.captureTask(taskName, promise);
 }
 
+function tryGetAllKeysSync() {
+    return cache.getAllKeys();
+}
+
 /**
  * Returns current key names stored in persisted storage
  * @private
@@ -133,6 +139,41 @@ function getAllKeys() {
     return cache.captureTask(taskName, promise);
 }
 
+function tryGetCachedValue(key, mapping = {}) {
+    if (Onyx.isCollectionKey(key)) {
+        const allKeys = Onyx.tryGetAllKeysSync()
+        const matchingKeys = allKeys.filter(k => k.startsWith(key))
+        const values = matchingKeys.reduce((finalObject, key, i) => {
+            const val = cache.getValue(key);
+            if (val) {
+                finalObject[key] = val;
+            }
+            return finalObject;
+        }, {})
+        if (Object.keys(values).length > 0) {
+            return values
+        }
+    }
+
+    if (!cache.hasCacheForKey(key)) {
+        return defaultKeyStates[key]; // We might have the value in the default key state
+    }
+
+    const val = cache.getValue(key);
+
+    // If the mapping has a selector, then the component's state must only be updated with the data
+    // returned by the selector.
+    if (mapping.selector) {
+        if (isCollectionKey(key)) {
+            return reduceCollectionWithSelector(val, mapping.selector, mapping.withOnyxInstance?.state);
+        } else {
+            return getSubsetOfData(val, mapping.selector, mapping.withOnyxInstance?.state);
+        }
+    }
+
+    return val;
+}
+
 /**
  * Checks to see if the a subscriber's supplied key
  * is associated with a collection of keys.
@@ -364,28 +405,34 @@ function keysChanged(collectionKey, partialCollection) {
                 // returned by the selector.
                 if (subscriber.selector) {
                     subscriber.withOnyxInstance.setState((prevState) => {
-                        const previousData = reduceCollectionWithSelector(prevState[subscriber.statePropertyName], subscriber.selector, subscriber.withOnyxInstance.state);
+                        const previousData = prevState[subscriber.statePropertyName];
                         const newData = reduceCollectionWithSelector(cachedCollection, subscriber.selector, subscriber.withOnyxInstance.state);
 
-                        if (!deepEqual(previousData, newData)) {
-                            return {
-                                [subscriber.statePropertyName]: newData,
-                            };
+                        if (deepEqual(previousData, newData)) {
+                            return null;
                         }
-                        return null;
+
+                        return {
+                            [subscriber.statePropertyName]: newData,
+                        };
                     });
                     continue;
                 }
 
                 subscriber.withOnyxInstance.setState((prevState) => {
-                    const finalCollection = _.clone(prevState[subscriber.statePropertyName] || {});
+                    const prevCollection = prevState[subscriber.statePropertyName]
+                    const finalCollection = _.clone(prevCollection || {});
                     const dataKeys = _.keys(partialCollection);
                     for (let j = 0; j < dataKeys.length; j++) {
                         const dataKey = dataKeys[j];
                         finalCollection[dataKey] = cachedCollection[dataKey];
                     }
 
-                    PerformanceUtils.logSetStateCall(subscriber, prevState[subscriber.statePropertyName], finalCollection, 'keysChanged', collectionKey);
+                    if (deepEqual(prevCollection, finalCollection)) {
+                        return null;
+                    }
+
+                    PerformanceUtils.logSetStateCall(subscriber, prevCollection, finalCollection, 'keysChanged', collectionKey);
                     return {
                         [subscriber.statePropertyName]: finalCollection,
                     };
@@ -405,34 +452,20 @@ function keysChanged(collectionKey, partialCollection) {
                 // If the subscriber has a selector, then the component's state must only be updated with the data
                 // returned by the selector and the state should only change when the subset of data changes from what
                 // it was previously.
-                if (subscriber.selector) {
-                    subscriber.withOnyxInstance.setState((prevState) => {
-                        const prevData = prevState[subscriber.statePropertyName];
-                        const newData = getSubsetOfData(cachedCollection[subscriber.key], subscriber.selector, subscriber.withOnyxInstance.state);
-                        if (!deepEqual(prevData, newData)) {
-                            PerformanceUtils.logSetStateCall(subscriber, prevData, newData, 'keysChanged', collectionKey);
-                            return {
-                                [subscriber.statePropertyName]: newData,
-                            };
-                        }
-
-                        return null;
-                    });
-                    continue;
-                }
-
                 subscriber.withOnyxInstance.setState((prevState) => {
+                    const prevData = prevState[subscriber.statePropertyName];
                     const data = cachedCollection[subscriber.key];
-                    const previousData = prevState[subscriber.statePropertyName];
-                    if (data === previousData) {
+                    const newData = subscriber.selector ? getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state) : data;
+                    if (deepEqual(prevData, newData)) {
                         return null;
                     }
                     
-                    PerformanceUtils.logSetStateCall(subscriber, previousData, data, 'keysChanged', collectionKey);
+                    PerformanceUtils.logSetStateCall(subscriber, prevData, newData, 'keysChanged', collectionKey);
                     return {
-                        [subscriber.statePropertyName]: data,
+                        [subscriber.statePropertyName]: newData,
                     };
                 });
+                continue;
             }
         }
     }
@@ -486,34 +519,20 @@ function keyChanged(key, data, canUpdateSubscriber) {
             if (isCollectionKey(subscriber.key)) {
                 // If the subscriber has a selector, then the consumer of this data must only be given the data
                 // returned by the selector and only when the selected data has changed.
-                if (subscriber.selector) {
-                    subscriber.withOnyxInstance.setState((prevState) => {
-                        const prevData = prevState[subscriber.statePropertyName];
-                        const newData = {
-                            [key]: getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state),
-                        };
-                        const prevDataWithNewData = {
-                            ...prevData,
-                            [key]: getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state),
-                        };
-                        if (!deepEqual(prevData, prevDataWithNewData)) {
-                            PerformanceUtils.logSetStateCall(subscriber, prevData, newData, 'keyChanged', key);
-                            return {
-                                [subscriber.statePropertyName]: prevDataWithNewData,
-                            };
-                        }
-                        return null;
-                    });
-                    continue;
-                }
-
                 subscriber.withOnyxInstance.setState((prevState) => {
-                    const collection = prevState[subscriber.statePropertyName] || {};
+                    const prevData = prevState[subscriber.statePropertyName] || {};
+                    const newData = {
+                        [key]: subscriber.selector ? getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state) : data,
+                    };
                     const newCollection = {
-                        ...collection,
-                        [key]: data,
+                        ...prevData,
+                        ...newData,
                     };
-                    PerformanceUtils.logSetStateCall(subscriber, collection, newCollection, 'keyChanged', key);
+                    if (deepEqual(prevData, newCollection)) {
+                        return null;
+                    }
+
+                    PerformanceUtils.logSetStateCall(subscriber, prevData, newCollection, 'keyChanged', key);
                     return {
                         [subscriber.statePropertyName]: newCollection,
                     };
@@ -523,30 +542,16 @@ function keyChanged(key, data, canUpdateSubscriber) {
 
             // If the subscriber has a selector, then the component's state must only be updated with the data
             // returned by the selector and only if the selected data has changed.
-            if (subscriber.selector) {
-                subscriber.withOnyxInstance.setState((prevState) => {
-                    const previousValue = getSubsetOfData(prevState[subscriber.statePropertyName], subscriber.selector, subscriber.withOnyxInstance.state);
-                    const newValue = getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state);
-                    if (!deepEqual(previousValue, newValue)) {
-                        return {
-                            [subscriber.statePropertyName]: newValue,
-                        };
-                    }
-                    return null;
-                });
-                continue;
-            }
-
-            // If we did not match on a collection key then we just set the new data to the state property
             subscriber.withOnyxInstance.setState((prevState) => {
-                const previousData = prevState[subscriber.statePropertyName];
-                if (previousData === data) {
+                const previousValue = prevState[subscriber.statePropertyName];
+                const newValue = subscriber.selector ? getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state) : data;
+                if (deepEqual(previousValue, newValue)) {
                     return null;
                 }
 
-                PerformanceUtils.logSetStateCall(subscriber, previousData, data, 'keyChanged', key);
+                PerformanceUtils.logSetStateCall(subscriber, previousValue, newValue, 'keyChanged', key);
                 return {
-                    [subscriber.statePropertyName]: data,
+                    [subscriber.statePropertyName]: newValue,
                 };
             });
             continue;
@@ -561,6 +566,8 @@ function keyChanged(key, data, canUpdateSubscriber) {
  *     - sets state on the withOnyxInstances
  *     - triggers the callback function
  * 
+ * Note: This is only invoked from Onyx.connect
+ *
  * @private
  * @param {Object} mapping
  * @param {Object} [mapping.withOnyxInstance]
@@ -590,7 +597,21 @@ function sendDataToConnection(mapping, val, matchedKey) {
             }
         }
 
+        // sendDataToConnection only get's called in the connect code.
+        // withOnyx is already setting data from cache initially. If we now
+        // want to call sendDataToConnection, we want to make sure, we
+        // are not sending again the same data from cache, if the component
+        // already has the cached data.
+        if (deepEqual(mapping.withOnyxInstance.state[mapping.statePropertyName], newData)) {
+            return;
+        }
+
         PerformanceUtils.logSetStateCall(mapping, null, newData, 'sendDataToConnection');
+        if (mapping.logging) {
+            console.log('------ Diff report', mapping.statePropertyName)
+            console.log(diff(mapping.withOnyxInstance.state[mapping.statePropertyName], newData))
+        }
+
         mapping.withOnyxInstance.setWithOnyxState(mapping.statePropertyName, newData);
         return;
     }
@@ -1303,7 +1324,10 @@ const Onyx = {
     addToEvictionBlockList,
     removeFromEvictionBlockList,
     isSafeEvictionKey,
+    isCollectionKey,
     METHOD,
+    tryGetCachedValue,
+    tryGetAllKeysSync,
 };
 
 /**
diff --git a/node_modules/react-native-onyx/lib/withOnyx.js b/node_modules/react-native-onyx/lib/withOnyx.js
index f8154d7..9ced564 100644
--- a/node_modules/react-native-onyx/lib/withOnyx.js
+++ b/node_modules/react-native-onyx/lib/withOnyx.js
@@ -8,6 +8,8 @@ import _ from 'underscore';
 import PropTypes from 'prop-types';
 import Str from 'expensify-common/lib/str';
 import Onyx from './Onyx';
+import { start } from '../../../src/pages/home/report/ReportActionsList'
+import Performance from 'react-native-performance'
 
 /**
  * Returns the display name of a component
@@ -30,6 +32,7 @@ export default function (mapOnyxToState) {
         class withOnyx extends React.Component {
             constructor(props) {
                 super(props);
+                this.start = performance.now()
 
                 this.setWithOnyxState = this.setWithOnyxState.bind(this);
 
@@ -37,13 +40,41 @@ export default function (mapOnyxToState) {
                 // disconnected. It is a key value store with the format {[mapping.key]: connectionID}.
                 this.activeConnectionIDs = {};
 
+                let cachedAssigments = 0;
+                this.cachedState = {};
+
+                // Check if we can get all the data synchronously from cache
+                _.each(mapOnyxToState, (mapping, propertyName) => {
+                    const key = Str.result(mapping.key, props);
+                    const value = Onyx.tryGetCachedValue(key, mapping);
+
+                    if (value !== undefined) {
+                        this.cachedState[propertyName] = value;
+                        cachedAssigments++;
+                    } else {
+                        console.log(`No cached value for ${key}`)
+                    }
+                });
+
+                // If there are no required keys for init then we can render the wrapped component immediately
+                const loading = cachedAssigments < requiredKeysForInit.length;
+                // console.log(displayName, requiredKeysForInit, loading)
+                this.rnd = Math.floor(Math.random() * 100000000)
+                if (loading) {
+                    Performance.mark(`blocking_${displayName}_${this.rnd}`)
+                    console.log("Keys missing:", requiredKeysForInit.filter(key => _.isUndefined(this.cachedState[key])))
+                    // debugger;
+                }
+
                 // Object holding the temporary initial state for the component while we load the various Onyx keys
-                this.tempState = {};
+                this.tempState = this.cachedState;
 
                 this.state = {
-                    // If there are no required keys for init then we can render the wrapped component immediately
-                    loading: requiredKeysForInit.length > 0,
-                };
+                    loading: loading,
+                    ...(loading ? {} : this.cachedState),
+                }
+
+                this.isFirstRender = true;
             }
 
             componentDidMount() {
@@ -88,6 +119,8 @@ export default function (mapOnyxToState) {
              * @param {*} val
              */
             setWithOnyxState(statePropertyName, val) {
+                console.log(displayName, 'setWithOnyxState', statePropertyName)
+
                 if (!this.state.loading) {
                     this.setState({[statePropertyName]: val});
                     return;
@@ -95,13 +128,19 @@ export default function (mapOnyxToState) {
 
                 this.tempState[statePropertyName] = val;
 
+                console.log(`added ${statePropertyName} to ${displayName}. Cached: ${Object.keys(this.cachedState)}`)
+
                 // All state keys should exist and at least have a value of null
                 if (_.some(requiredKeysForInit, key => _.isUndefined(this.tempState[key]))) {
                     return;
                 }
 
+                console.log("Diff", this.state[statePropertyName], val);
                 this.setState({...this.tempState, loading: false});
                 delete this.tempState;
+
+                // Performance.mark(`unblocking_${displayName}_${this.rnd}`)
+                // Performance.measure(`blocked_time_${displayName}_${this.rnd}_${statePropertyName}`, `blocking_${displayName}_${this.rnd}`, `unblocking_${displayName}_${this.rnd}`)
             }
 
             /**
@@ -158,9 +197,24 @@ export default function (mapOnyxToState) {
 
             render() {
                 if (this.state.loading) {
-                    return null;
+                    console.log(`blocking ${displayName} time:${performance.now() - this.start}`)
+                    const Comp = () => {
+                        return null;
+                    }
+                    Comp.displayName = `blocking ${displayName}`
+                    return <Comp/>;
+                } else {
+                    if (this.isFirstRender) {
+                        this.isFirstRender = false;
+                        Performance.mark(`unblocking_${displayName}_${this.rnd}`)
+                        try {
+                            Performance.measure(`blocked_time_${displayName}_${this.rnd}`, `blocking_${displayName}_${this.rnd}`, `unblocking_${displayName}_${this.rnd}`)
+                        } catch{}
+                    }
                 }
 
+
+                console.log(`unblocking ${displayName} time:${performance.now() - this.start}`)
                 // Remove any internal state properties used by withOnyx
                 // that should not be passed to a wrapped component
                 let stateToPass = _.omit(this.state, 'loading');
