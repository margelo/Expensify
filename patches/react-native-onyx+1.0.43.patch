diff --git a/node_modules/react-native-onyx/lib/Onyx.js b/node_modules/react-native-onyx/lib/Onyx.js
index 7b45997..f4abf69 100644
--- a/node_modules/react-native-onyx/lib/Onyx.js
+++ b/node_modules/react-native-onyx/lib/Onyx.js
@@ -73,6 +73,8 @@ const reduceCollectionWithSelector = (collection, selector, withOnyxInstanceStat
     return finalCollection;
 }, {});
 
+
+
 /**
  * Get some data from the store
  *
@@ -104,6 +106,10 @@ function get(key) {
     return cache.captureTask(taskName, promise);
 }
 
+function tryGetAllKeysSync() {
+    return cache.getAllKeys();
+}
+
 /**
  * Returns current key names stored in persisted storage
  * @private
@@ -133,6 +139,41 @@ function getAllKeys() {
     return cache.captureTask(taskName, promise);
 }
 
+function tryGetCachedValue(key, mapping = {}) {
+    if (Onyx.isCollectionKey(key)) {
+        const allKeys = Onyx.tryGetAllKeysSync()
+        const matchingKeys = allKeys.filter(k => k.startsWith(key))
+        const values = matchingKeys.reduce((finalObject, key, i) => {
+            const val = cache.getValue(key);
+            if (val) {
+                finalObject[key] = val;
+            }
+            return finalObject;
+        }, {})
+        if (Object.keys(values).length > 0) {
+            return values
+        }
+    }
+
+    if (!cache.hasCacheForKey(key)) {
+        return undefined
+    }
+
+    const val = cache.getValue(key);
+
+    // If the mapping has a selector, then the component's state must only be updated with the data
+    // returned by the selector.
+    if (mapping.selector) {
+        if (isCollectionKey(key)) {
+            return reduceCollectionWithSelector(val, mapping.selector, mapping.withOnyxInstance?.state);
+        } else {
+            return getSubsetOfData(val, mapping.selector, mapping.withOnyxInstance?.state);
+        }
+    }
+
+    return val;
+}
+
 /**
  * Checks to see if the a subscriber's supplied key
  * is associated with a collection of keys.
@@ -364,7 +405,7 @@ function keysChanged(collectionKey, partialCollection) {
                 // returned by the selector.
                 if (subscriber.selector) {
                     subscriber.withOnyxInstance.setState((prevState) => {
-                        const previousData = reduceCollectionWithSelector(prevState[subscriber.statePropertyName], subscriber.selector, subscriber.withOnyxInstance.state);
+                        const previousData = prevState[subscriber.statePropertyName];
                         const newData = reduceCollectionWithSelector(cachedCollection, subscriber.selector, subscriber.withOnyxInstance.state);
 
                         if (!deepEqual(previousData, newData)) {
@@ -494,7 +535,7 @@ function keyChanged(key, data, canUpdateSubscriber) {
                         };
                         const prevDataWithNewData = {
                             ...prevData,
-                            [key]: getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state),
+                            ...newData,
                         };
                         if (!deepEqual(prevData, prevDataWithNewData)) {
                             PerformanceUtils.logSetStateCall(subscriber, prevData, newData, 'keyChanged', key);
@@ -507,17 +548,28 @@ function keyChanged(key, data, canUpdateSubscriber) {
                     continue;
                 }
 
-                subscriber.withOnyxInstance.setState((prevState) => {
-                    const collection = prevState[subscriber.statePropertyName] || {};
-                    const newCollection = {
-                        ...collection,
-                        [key]: data,
-                    };
-                    PerformanceUtils.logSetStateCall(subscriber, collection, newCollection, 'keyChanged', key);
-                    return {
-                        [subscriber.statePropertyName]: newCollection,
-                    };
-                });
+                const collection = subscriber.withOnyxInstance.state[subscriber.statePropertyName] || {};
+                const newCollection = {
+                    ...collection,
+                    [key]: data,
+                };
+                sendDataToConnection(
+                    subscriber,
+                    newCollection,
+                    subscriber.key,
+                )
+
+                // subscriber.withOnyxInstance.setState((prevState) => {
+                //     const collection = prevState[subscriber.statePropertyName] || {};
+                //     const newCollection = {
+                //         ...collection,
+                //         [key]: data,
+                //     };
+                //     PerformanceUtils.logSetStateCall(subscriber, collection, newCollection, 'keyChanged', key);
+                //     return {
+                //         [subscriber.statePropertyName]: newCollection,
+                //     };
+                // });
                 continue;
             }
 
@@ -525,7 +577,7 @@ function keyChanged(key, data, canUpdateSubscriber) {
             // returned by the selector and only if the selected data has changed.
             if (subscriber.selector) {
                 subscriber.withOnyxInstance.setState((prevState) => {
-                    const previousValue = getSubsetOfData(prevState[subscriber.statePropertyName], subscriber.selector, subscriber.withOnyxInstance.state);
+                    const previousValue = prevState[subscriber.statePropertyName];
                     const newValue = getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state);
                     if (!deepEqual(previousValue, newValue)) {
                         return {
@@ -538,17 +590,27 @@ function keyChanged(key, data, canUpdateSubscriber) {
             }
 
             // If we did not match on a collection key then we just set the new data to the state property
-            subscriber.withOnyxInstance.setState((prevState) => {
-                const previousData = prevState[subscriber.statePropertyName];
-                if (previousData === data) {
-                    return null;
-                }
+            if (subscriber.withOnyxInstance.state[subscriber.statePropertyName] === data) {
+                continue;
+            }
 
-                PerformanceUtils.logSetStateCall(subscriber, previousData, data, 'keyChanged', key);
-                return {
-                    [subscriber.statePropertyName]: data,
-                };
-            });
+            sendDataToConnection(
+                subscriber,
+                data,
+                subscriber.key,
+            )
+            // subscriber.withOnyxInstance.setState((prevState) => {
+            //     const previousData = prevState[subscriber.statePropertyName];
+            //     if (previousData === data) {
+            //         return null;
+            //     }
+
+            //     console.log('keyChanged', key, key === "network" ? data : undefined)
+            //     PerformanceUtils.logSetStateCall(subscriber, previousData, data, 'keyChanged', key);
+            //     return {
+            //         [subscriber.statePropertyName]: data,
+            //     };
+            // });
             continue;
         }
 
@@ -556,6 +618,7 @@ function keyChanged(key, data, canUpdateSubscriber) {
     }
 }
 
+const {diff} = require('jest-diff');
 /**
  * Sends the data obtained from the keys to the connection. It either:
  *     - sets state on the withOnyxInstances
@@ -590,9 +653,16 @@ function sendDataToConnection(mapping, val, matchedKey) {
             }
         }
 
-        PerformanceUtils.logSetStateCall(mapping, null, newData, 'sendDataToConnection');
-        mapping.withOnyxInstance.setWithOnyxState(mapping.statePropertyName, newData);
-        return;
+        if (!deepEqual(mapping.withOnyxInstance.state[mapping.statePropertyName], newData)) {
+            PerformanceUtils.logSetStateCall(mapping, null, newData, 'sendDataToConnection');
+            if (mapping.logging) {
+                console.log('------ Diff report', mapping.statePropertyName)
+                console.log(diff(mapping.withOnyxInstance.state[mapping.statePropertyName], newData))
+            }
+
+            mapping.withOnyxInstance.setWithOnyxState(mapping.statePropertyName, newData);
+            return;
+        }
     }
 
     if (_.isFunction(mapping.callback)) {
@@ -1303,7 +1373,10 @@ const Onyx = {
     addToEvictionBlockList,
     removeFromEvictionBlockList,
     isSafeEvictionKey,
+    isCollectionKey,
     METHOD,
+    tryGetCachedValue,
+    tryGetAllKeysSync,
 };
 
 /**
diff --git a/node_modules/react-native-onyx/lib/withOnyx.js b/node_modules/react-native-onyx/lib/withOnyx.js
index f8154d7..a9cc625 100644
--- a/node_modules/react-native-onyx/lib/withOnyx.js
+++ b/node_modules/react-native-onyx/lib/withOnyx.js
@@ -8,6 +8,8 @@ import _ from 'underscore';
 import PropTypes from 'prop-types';
 import Str from 'expensify-common/lib/str';
 import Onyx from './Onyx';
+import { start } from '../../../src/pages/home/report/ReportActionsList'
+import Performance from 'react-native-performance'
 
 /**
  * Returns the display name of a component
@@ -30,6 +32,7 @@ export default function (mapOnyxToState) {
         class withOnyx extends React.Component {
             constructor(props) {
                 super(props);
+                this.start = performance.now()
 
                 this.setWithOnyxState = this.setWithOnyxState.bind(this);
 
@@ -37,13 +40,42 @@ export default function (mapOnyxToState) {
                 // disconnected. It is a key value store with the format {[mapping.key]: connectionID}.
                 this.activeConnectionIDs = {};
 
+                let cachedAssigments = 0;
+                this.cachedState = {};
+
+                // Check if we can get all the data synchronously from cache
+                _.each(mapOnyxToState, (mapping, propertyName) => {
+                    const key = Str.result(mapping.key, props);
+                    const value = Onyx.tryGetCachedValue(key, mapping);
+
+                    if (value !== undefined) {
+                        this.cachedState[propertyName] = value;
+                        cachedAssigments++;
+                    } else {
+                        console.log(`No cached value for ${key}`)
+                        // console.log(Onyx.tryGetAllKeysSync())
+                    }
+                });
+
+                // If there are no required keys for init then we can render the wrapped component immediately
+                const loading = cachedAssigments < requiredKeysForInit.length;
+                // console.log(displayName, requiredKeysForInit, loading)
+                this.rnd = Math.floor(Math.random() * 100000000)
+                if (loading) {
+                    Performance.mark(`blocking_${displayName}_${this.rnd}`)
+                    console.log("Keys missing:", requiredKeysForInit.filter(key => _.isUndefined(this.cachedState[key])))
+                    // debugger;
+                }
+
                 // Object holding the temporary initial state for the component while we load the various Onyx keys
-                this.tempState = {};
+                this.tempState = this.cachedState;
 
                 this.state = {
-                    // If there are no required keys for init then we can render the wrapped component immediately
-                    loading: requiredKeysForInit.length > 0,
-                };
+                    loading: loading,
+                    ...(loading ? {} : this.cachedState),
+                }
+
+                this.isFirstRender = true;
             }
 
             componentDidMount() {
@@ -65,6 +97,7 @@ export default function (mapOnyxToState) {
                         Onyx.disconnect(this.activeConnectionIDs[previousKey], previousKey);
                         delete this.activeConnectionIDs[previousKey];
                         this.connectMappingToOnyx(mapping, propertyName);
+                        console.log('reconnect:', displayName, this.activeConnectionIDs[newKey])
                     }
                 });
                 this.checkEvictableKeys();
@@ -76,6 +109,7 @@ export default function (mapOnyxToState) {
                     const key = Str.result(mapping.key, this.props);
                     const connectionID = this.activeConnectionIDs[key];
                     Onyx.disconnect(connectionID, key);
+                    console.log('disconnect:', displayName, connectionID);
                 });
             }
 
@@ -88,6 +122,8 @@ export default function (mapOnyxToState) {
              * @param {*} val
              */
             setWithOnyxState(statePropertyName, val) {
+                console.log(displayName, 'setWithOnyxState', statePropertyName)
+
                 if (!this.state.loading) {
                     this.setState({[statePropertyName]: val});
                     return;
@@ -95,13 +131,22 @@ export default function (mapOnyxToState) {
 
                 this.tempState[statePropertyName] = val;
 
+                console.log(`added ${statePropertyName} to ${displayName}. Cached: ${Object.keys(this.cachedState)}`)
+                // if (displayName === 'ReportScreenWrapper') {
+                //     debugger;
+                // }
+
                 // All state keys should exist and at least have a value of null
                 if (_.some(requiredKeysForInit, key => _.isUndefined(this.tempState[key]))) {
                     return;
                 }
 
+                console.log("Diff", this.state[statePropertyName], val);
                 this.setState({...this.tempState, loading: false});
                 delete this.tempState;
+
+                // Performance.mark(`unblocking_${displayName}_${this.rnd}`)
+                // Performance.measure(`blocked_time_${displayName}_${this.rnd}_${statePropertyName}`, `blocking_${displayName}_${this.rnd}`, `unblocking_${displayName}_${this.rnd}`)
             }
 
             /**
@@ -154,13 +199,29 @@ export default function (mapOnyxToState) {
                     withOnyxInstance: this,
                     displayName,
                 });
+                console.log("connect:", displayName, this.activeConnectionIDs[key])
             }
 
             render() {
                 if (this.state.loading) {
-                    return null;
+                    console.log(`blocking ${displayName} time:${performance.now() - this.start}`)
+                    const Comp = () => {
+                        return null;
+                    }
+                    Comp.displayName = `blocking ${displayName}`
+                    return <Comp/>;
+                } else {
+                    if (this.isFirstRender) {
+                        this.isFirstRender = false;
+                        Performance.mark(`unblocking_${displayName}_${this.rnd}`)
+                        try {
+                            Performance.measure(`blocked_time_${displayName}_${this.rnd}`, `blocking_${displayName}_${this.rnd}`, `unblocking_${displayName}_${this.rnd}`)
+                        } catch{}
+                    }
                 }
 
+
+                console.log(`unblocking ${displayName} time:${performance.now() - this.start}`)
                 // Remove any internal state properties used by withOnyx
                 // that should not be passed to a wrapped component
                 let stateToPass = _.omit(this.state, 'loading');
